        function getMetricsForSupervisors(supervisorsList) {
            // Helper to init metrics structure
            const createMetric = () => ({
                fat: 0, vol: 0, prevFat: 0, prevVol: 0,
                prevClientsSet: new Set(),
                quarterlyPosClientsSet: new Set(), // New Set for Quarter Active
                monthlyClientsSets: new Map() // Map<MonthKey, Set<CodCli>>
            });

            const metricsMap = {
                '707': createMetric(),
                '708': createMetric(),
                '752': createMetric(),
                '1119_TODDYNHO': createMetric(),
                '1119_TODDY': createMetric(),
                '1119_QUAKER_KEROCOCO': createMetric(),
                'PEPSICO_ALL': createMetric()
            };

            const currentDate = lastSaleDate;
            const prevMonthDate = new Date(Date.UTC(currentDate.getUTCFullYear(), currentDate.getUTCMonth() - 1, 1));
            const prevMonthIndex = prevMonthDate.getUTCMonth();
            const prevMonthYear = prevMonthDate.getUTCFullYear();

            // Filter clients to match the "Active Structure" definition (Same as Coverage/Goals Table)
            let activeClients = allClientsData.filter(c => {
                const rca1 = String(c.rca1 || '').trim();
                const isAmericanas = (c.razaoSocial || '').toUpperCase().includes('AMERICANAS');
                if (isAmericanas) return true;
                if (rca1 === '53' || rca1 === '' || rca1 === 'INATIVOS') return false;
                return true;
            });

            // Filter by Supervisors if provided
            if (supervisorsList && supervisorsList.length > 0) {
                const supervisorsSet = new Set(supervisorsList);
                const rcasSet = new Set();
                supervisorsSet.forEach(sup => {
                    (optimizedData.rcasBySupervisor.get(sup) || []).forEach(rca => rcasSet.add(rca));
                });
                activeClients = activeClients.filter(c => c.rcas.some(r => rcasSet.has(r)));
            }

            activeClients.forEach(client => {
                const codCli = client['Código'];
                const clientHistoryIds = optimizedData.indices.history.byClient.get(codCli);

                // Temp accumulation for this client to ensure Positive Balance check
                const clientTotals = {}; // key -> { prevFat: 0, monthlyFat: Map<MonthKey, val> }

                if (clientHistoryIds) {
                    clientHistoryIds.forEach(id => {
                        const sale = optimizedData.historyById.get(id);
                        // EXCEPTION: Exclude Balcão (53) sales for Client 9569 from Summary Metrics
                        if (String(codCli).trim() === '9569' && (String(sale.CODUSUR).trim() === '53' || String(sale.CODUSUR).trim() === '053')) return;

                        let key = null;
                        const codFor = String(sale.CODFOR);

                        if (codFor === '707') key = '707';
                        else if (codFor === '708') key = '708';
                        else if (codFor === '752') key = '752';
                        else if (codFor === '1119') {
                            const desc = normalize(sale.DESCRICAO || '');
                            if (desc.includes('TODDYNHO')) key = '1119_TODDYNHO';
                            else if (desc.includes('TODDY')) key = '1119_TODDY';
                            else if (desc.includes('QUAKER') || desc.includes('KEROCOCO')) key = '1119_QUAKER_KEROCOCO';
                        }

                        const keysToProcess = [];
                        if (key && metricsMap[key]) keysToProcess.push(key);
                        if (['707', '708', '752', '1119'].includes(codFor)) keysToProcess.push('PEPSICO_ALL');

                        keysToProcess.forEach(procKey => {
                            const d = parseDate(sale.DTPED);
                            const isPrevMonth = d && d.getUTCMonth() === prevMonthIndex && d.getUTCFullYear() === prevMonthYear;

                            // 1. Revenue/Volume metrics (Types 1 & 9) - Global Sums
                            if (sale.TIPOVENDA === '1' || sale.TIPOVENDA === '9') {
                                metricsMap[procKey].fat += sale.VLVENDA;
                                metricsMap[procKey].vol += sale.TOTPESOLIQ;

                                if (isPrevMonth) {
                                    metricsMap[procKey].prevFat += sale.VLVENDA;
                                    metricsMap[procKey].prevVol += sale.TOTPESOLIQ;
                                }

                                // 2. Accumulate for Client Count Check (Balance per period)
                                if (d) {
                                    if (!clientTotals[procKey]) clientTotals[procKey] = { prevFat: 0, monthlyFat: new Map() };

                                    if (isPrevMonth) clientTotals[procKey].prevFat += sale.VLVENDA;

                                    const monthKey = `${d.getUTCFullYear()}-${d.getUTCMonth()}`;
                                    const currentMVal = clientTotals[procKey].monthlyFat.get(monthKey) || 0;
                                    clientTotals[procKey].monthlyFat.set(monthKey, currentMVal + sale.VLVENDA);
                                }
                            }
                        });
                    });
                }

                // Check thresholds for this client
                for (const key in clientTotals) {
                    const t = clientTotals[key];

                    // Calculate Total Quarter Fat for this client/key to determine Meta Pos
                    let totalQuarterFat = 0;
                    t.monthlyFat.forEach(val => totalQuarterFat += val);

                    if (totalQuarterFat > 1) {
                        metricsMap[key].quarterlyPosClientsSet.add(codCli);
                    }

                    if (t.prevFat > 1) {
                        metricsMap[key].prevClientsSet.add(codCli);
                    }
                    t.monthlyFat.forEach((val, mKey) => {
                        if (val > 1) {
                            if (!metricsMap[key].monthlyClientsSets.has(mKey)) {
                                metricsMap[key].monthlyClientsSets.set(mKey, new Set());
                            }
                            metricsMap[key].monthlyClientsSets.get(mKey).add(codCli);
                        }
                    });
                }
            });

            // Calculate Averages and Finalize
            for (const key in metricsMap) {
                const m = metricsMap[key];

                m.avgFat = m.fat / QUARTERLY_DIVISOR;
                m.avgVol = m.vol / QUARTERLY_DIVISOR; // Kg
                m.prevVol = m.prevVol; // Kg

                m.prevClients = m.prevClientsSet.size;
                m.quarterlyPos = m.quarterlyPosClientsSet.size; // New Metric

                let sumClients = 0;
                m.monthlyClientsSets.forEach(set => sumClients += set.size);
                m.avgClients = sumClients / QUARTERLY_DIVISOR;
            }
            return metricsMap;
        }

        function updateGoalsSummaryView() {
            const container = document.getElementById('goals-summary-grid');
            if (!container) return;

            // Use the independent summary filter
            const displayMetrics = getMetricsForSupervisors(selectedGoalsSummarySupervisors);

            // Calculate Target Sums for Filtered Subset
            // 1. Identify clients matching the summary filter
            let filteredSummaryClients = allClientsData;

            // Apply "Active" Filter logic (Consistent with other Goal Views)
            filteredSummaryClients = filteredSummaryClients.filter(c => {
                const rca1 = String(c.rca1 || '').trim();
                const isAmericanas = (c.razaoSocial || '').toUpperCase().includes('AMERICANAS');
